require('dotenv').config();
const { Telegraf } = require('telegraf');
const TaskAtomizerCLI = require('./atomizer/TaskAtomizerCLI');
const DatabaseManager = require('./database/DatabaseManager');
const LinearManager = require('./integrations/LinearManager');
const GitHubManager = require('./integrations/GitHubManager');
const path = require('path');

class TelegramTaskBot {
  constructor() {
    this.bot = new Telegraf(process.env.TELEGRAM_BOT_TOKEN);
    this.atomizer = new TaskAtomizerCLI();
    this.db = new DatabaseManager();
    this.linear = new LinearManager(process.env.LINEAR_API_KEY);
    this.github = new GitHubManager(process.env.GITHUB_TOKEN);
    this.projects = new Map(); // En memoria para el MVP
    this.linearCache = new Map(); // Cache para equipos y proyectos
    this.githubCache = new Map(); // Cache para repos y estructuras
    this.selectedRepositories = new Map(); // Repos seleccionados por usuario
    
    this.setupCommands();
    this.setupMiddleware();
  }

  setupMiddleware() {
    // Logging middleware
    this.bot.use((ctx, next) => {
      const user = ctx.from.username || ctx.from.first_name || 'unknown';
      console.log(`üì® [${new Date().toISOString()}] ${user}: ${ctx.message?.text || ctx.update.callback_query?.data || 'action'}`);
      return next();
    });

    // Error handling
    this.bot.catch((err, ctx) => {
      console.error('‚ùå Bot error:', err);
      ctx.reply('‚ùå Ocurri√≥ un error inesperado. Intenta nuevamente.');
    });
  }

  setupCommands() {
    // Comando de inicio
    this.bot.command('start', (ctx) => {
      const welcomeMessage = `
ü§ñ **Telegram Task Agent** - ¬°Bienvenido!

Sistema de agentes atomizados que descompone proyectos complejos en tareas ejecutables.

**Comandos disponibles:**

**üîó Integraciones:**
/linear - Ver equipos y proyectos Linear
/tasks [team_key] - Ver tareas de un equipo
/project_tasks [project_name] - Ver tareas de proyecto
/atomize [issue_id] - Atomizar tarea Linear espec√≠fica

/repos - Ver repositorios GitHub disponibles
/select_repo [owner/repo] - Seleccionar repositorio
/repo_structure [owner/repo] - Ver estructura del repo
/my_repos - Ver repositorios seleccionados

**‚öôÔ∏è Core:**
/project - Atomizar un proyecto nuevo
/list - Ver proyectos y tareas
/status - Estado del sistema
/help - Ayuda detallada

**¬øC√≥mo empezar?**
1. Usa \`/project "Descripci√≥n de tu proyecto"\`
2. Sigue las instrucciones para atomizar con Claude CLI
3. Ejecuta las tareas resultantes

üí° **Ejemplo:**
\`/project "Crear una API REST para manejo de tareas con autenticaci√≥n JWT"\`
      `;
      
      ctx.replyWithMarkdown(welcomeMessage);
    });

    // Comando principal: atomizar proyecto
    this.bot.command('project', async (ctx) => {
      const projectDescription = ctx.message.text.replace('/project', '').trim();
      
      if (!projectDescription) {
        return ctx.replyWithMarkdown(`
‚ùå **Descripci√≥n requerida**

**Uso:** \`/project "descripci√≥n completa del proyecto"\`

**Ejemplo:**
\`/project "Desarrollar un sistema de chat en tiempo real con React, Node.js, Socket.io y MongoDB"\`
        `);
      }

      await this.handleProjectAtomization(ctx, projectDescription);
    });

    // Listar proyectos y tareas
    this.bot.command('list', (ctx) => {
      if (this.projects.size === 0) {
        return ctx.replyWithMarkdown(`
üìã **No hay proyectos activos**

Crea tu primer proyecto con:
\`/project "descripci√≥n de tu proyecto"\`
        `);
      }

      this.sendProjectsList(ctx);
    });

    // Estado del sistema
    this.bot.command('status', (ctx) => {
      const status = this.getSystemStatus();
      ctx.replyWithMarkdown(status);
    });

    // Ayuda detallada
    this.bot.command('help', (ctx) => {
      const helpMessage = `
üìö **Telegram Task Agent - Gu√≠a Completa**

**üéØ ¬øQu√© hace?**
Descompone proyectos complejos en tareas at√≥micas ejecutables por Docker containers independientes.

**üîß Comandos principales:**

**\`/project "descripci√≥n"\`**
- Atomiza tu proyecto en tareas ejecutables
- Integraci√≥n con Claude CLI (gratis)
- Genera prompt optimizado para atomizaci√≥n

**\`/list\`**
- Muestra todos los proyectos y sus tareas
- Estados: pendiente, en progreso, completado
- Dependencias y orden de ejecuci√≥n

**\`/status\`**
- Estado general del sistema
- Proyectos activos y estad√≠sticas
- Informaci√≥n de configuraci√≥n

**üí° Flujo de trabajo:**
1. \`/project "Mi proyecto incre√≠ble"\` 
2. Bot genera prompt para Claude CLI
3. Ejecutas: \`claude --file="prompt.md"\`
4. Pegas la respuesta JSON en el chat
5. Bot procesa y muestra tareas listas para ejecutar

**üöÄ Ventajas:**
‚úÖ Costo $0 (usa tu suscripci√≥n Claude)
‚úÖ Tareas completamente independientes
‚úÖ Orden de ejecuci√≥n autom√°tico
‚úÖ Comandos Docker espec√≠ficos
      `;
      
      ctx.replyWithMarkdown(helpMessage);
    });

    // Comandos Linear Integration
    this.bot.command('linear', async (ctx) => {
      await this.handleLinearCommand(ctx);
    });

    this.bot.command('tasks', async (ctx) => {
      await this.handleTasksCommand(ctx);
    });

    this.bot.command('project_tasks', async (ctx) => {
      await this.handleProjectTasksCommand(ctx);
    });

    this.bot.command('atomize', async (ctx) => {
      await this.handleAtomizeCommand(ctx);
    });

    // Comandos GitHub Integration
    this.bot.command('repos', async (ctx) => {
      await this.handleReposCommand(ctx);
    });

    this.bot.command('select_repo', async (ctx) => {
      await this.handleSelectRepoCommand(ctx);
    });

    this.bot.command('repo_structure', async (ctx) => {
      await this.handleRepoStructureCommand(ctx);
    });

    this.bot.command('my_repos', async (ctx) => {
      await this.handleMyReposCommand(ctx);
    });

    // Comando para procesar respuesta de Claude CLI
    this.bot.hears(/^\\{[\\s\\S]*\\}$/, async (ctx) => {
      await this.handleClaudeResponse(ctx);
    });
  }

  async handleProjectAtomization(ctx, projectDescription) {
    const userId = ctx.from.id;
    const projectId = `proj_${Date.now()}_${userId}`;

    try {
      // Enviar mensaje de procesamiento
      const processingMsg = await ctx.replyWithMarkdown('‚öôÔ∏è **Generando prompt para atomizaci√≥n...**');

      // Generar prompt con TaskAtomizer CLI
      const result = this.atomizer.generateAtomizationPrompt(projectDescription, {
        maxTasks: 12,
        complexity: 'medium'
      });

      // Guardar contexto del proyecto
      this.projects.set(projectId, {
        id: projectId,
        userId: userId,
        description: projectDescription,
        status: 'awaiting_claude_response',
        promptFile: result.promptFile,
        createdAt: new Date().toISOString()
      });

      // Eliminar mensaje de procesamiento
      await ctx.deleteMessage(processingMsg.message_id);

      // Enviar instrucciones con el prompt generado
      const instructionsMessage = `
üéØ **Proyecto listo para atomizaci√≥n**

**üìã Proyecto:** ${projectDescription.slice(0, 50)}${projectDescription.length > 50 ? '...' : ''}
**üìÅ Prompt generado:** \`${path.basename(result.promptFile)}\`

**üöÄ SIGUIENTE PASO:**

1Ô∏è‚É£ **Ejecuta Claude CLI:**
\`\`\`bash
claude --file="${result.promptFile}"
\`\`\`

2Ô∏è‚É£ **Copia la respuesta JSON completa** (solo el JSON, sin explicaciones)

3Ô∏è‚É£ **P√©gala aqu√≠ en el chat** - El bot la procesar√° autom√°ticamente

**üí° Alternativa:**
\`\`\`bash
claude < "${result.promptFile}"
\`\`\`

**‚è±Ô∏è Timeout:** Este prompt expira en 30 minutos.
      `;

      await ctx.replyWithMarkdown(instructionsMessage);

      // Programar limpieza del prompt temporal
      setTimeout(() => {
        if (this.projects.has(projectId) && this.projects.get(projectId).status === 'awaiting_claude_response') {
          this.projects.delete(projectId);
        }
      }, 30 * 60 * 1000); // 30 minutos

    } catch (error) {
      console.error('Error in project atomization:', error);
      await ctx.replyWithMarkdown(`
‚ùå **Error al generar prompt**

${error.message}

Intenta nuevamente con una descripci√≥n m√°s espec√≠fica.
      `);
    }
  }

  async handleClaudeResponse(ctx) {
    const userId = ctx.from.id;
    const jsonResponse = ctx.message.text.trim();

    // Buscar proyecto activo del usuario
    const activeProject = Array.from(this.projects.values())
      .find(p => p.userId === userId && p.status === 'awaiting_claude_response');

    if (!activeProject) {
      return ctx.replyWithMarkdown(`
‚ùå **No hay proyecto activo esperando respuesta**

Inicia un nuevo proyecto con:
\`/project "descripci√≥n de tu proyecto"\`
      `);
    }

    try {
      // Mostrar mensaje de procesamiento
      const processingMsg = await ctx.replyWithMarkdown('üîÑ **Procesando respuesta de Claude...**');

      // Parsear respuesta con TaskAtomizer
      const result = this.atomizer.parseAtomizedResponse(jsonResponse);

      // Actualizar proyecto con las tareas atomizadas
      activeProject.status = 'atomized';
      activeProject.atomizedResult = result;
      activeProject.processedAt = new Date().toISOString();

      // Eliminar mensaje de procesamiento
      await ctx.deleteMessage(processingMsg.message_id);

      // Mostrar resumen del proyecto atomizado
      await this.sendAtomizedProjectSummary(ctx, activeProject);

    } catch (error) {
      console.error('Error processing Claude response:', error);
      await ctx.replyWithMarkdown(`
‚ùå **Error al procesar respuesta de Claude**

**Posibles causas:**
- JSON inv√°lido o incompleto
- Formato de respuesta incorrecto
- Respuesta cortada

**üí° Aseg√∫rate de:**
- Copiar **todo** el JSON generado por Claude
- Incluir desde \`{\` hasta \`}\`
- No agregar texto adicional

**Error detalle:** ${error.message}
      `);
    }
  }

  async sendAtomizedProjectSummary(ctx, project) {
    const result = project.atomizedResult;
    
    const summaryMessage = `
‚úÖ **Proyecto atomizado exitosamente**

**üìã ${result.project.title}**
**üéØ Complejidad:** ${result.project.complexity}
**‚è±Ô∏è Duraci√≥n estimada:** ${result.project.estimatedDuration}
**üîß Tech Stack:** ${result.project.techStack?.join(', ') || 'N/A'}

**üìä Estad√≠sticas:**
‚Ä¢ **Tareas generadas:** ${result.tasks.length}
‚Ä¢ **Dependencias:** ${result.dependencies.length}
‚Ä¢ **Costo:** ${result.costs.note}

**üîó Orden de ejecuci√≥n calculado:**
${result.executionOrder.map((task, i) => 
  `${i + 1}. \`${task.id}\` - ${task.title}`
).join('\\n')}

**üöÄ Pr√≥ximos pasos:**
‚Ä¢ Usa \`/list\` para ver detalles de cada tarea
‚Ä¢ Implementar sistema de ejecuci√≥n Docker
‚Ä¢ Monitoreo en tiempo real

*Proyecto guardado como: ${project.id}*
    `;

    await ctx.replyWithMarkdown(summaryMessage);
  }

  sendProjectsList(ctx) {
    const projects = Array.from(this.projects.values());
    
    let message = 'üìã **Proyectos activos:**\\n\\n';
    
    projects.forEach(project => {
      const status = this.getProjectStatusEmoji(project.status);
      const title = project.atomizedResult ? 
        project.atomizedResult.project.title : 
        project.description.slice(0, 40) + '...';
      
      message += `${status} **${title}**\\n`;
      message += `   ID: \`${project.id}\`\\n`;
      message += `   Estado: ${project.status}\\n`;
      
      if (project.atomizedResult) {
        message += `   Tareas: ${project.atomizedResult.tasks.length}\\n`;
      }
      
      message += `\\n`;
    });

    ctx.replyWithMarkdown(message);
  }

  getProjectStatusEmoji(status) {
    const statusEmojis = {
      'awaiting_claude_response': '‚è≥',
      'atomized': '‚úÖ',
      'executing': 'üîÑ',
      'completed': 'üéâ',
      'failed': '‚ùå'
    };
    return statusEmojis[status] || '‚ùì';
  }

  getSystemStatus() {
    const projectCount = this.projects.size;
    const atomizedCount = Array.from(this.projects.values())
      .filter(p => p.status === 'atomized').length;
    
    return `
ü§ñ **Estado del Sistema**

**üìä Estad√≠sticas:**
‚Ä¢ Proyectos activos: ${projectCount}
‚Ä¢ Proyectos atomizados: ${atomizedCount}
‚Ä¢ Sistema: Operativo ‚úÖ

**‚öôÔ∏è Configuraci√≥n:**
‚Ä¢ TaskAtomizer: Claude CLI Ready
‚Ä¢ Database: ${this.db ? 'Conectado' : 'Desconectado'}
‚Ä¢ Bot Token: ${process.env.TELEGRAM_BOT_TOKEN ? 'Configurado' : 'Faltante'}

**üíæ Memoria:**
‚Ä¢ Proyectos en RAM: ${projectCount}
‚Ä¢ Uptime: ${Math.floor(process.uptime() / 60)} minutos

*Versi√≥n: Telegram Task Agent MVP*
    `;
  }

  // Handlers para comandos Linear
  async handleLinearCommand(ctx) {
    try {
      const processingMsg = await ctx.replyWithMarkdown('üîÑ **Cargando datos de Linear...**');

      // Obtener equipos y proyectos en paralelo
      const [teams, projects] = await Promise.all([
        this.linear.getTeams(),
        this.linear.getProjects()
      ]);

      // Cache para uso posterior
      this.linearCache.set('teams', teams);
      this.linearCache.set('projects', projects);

      await ctx.deleteMessage(processingMsg.message_id);

      // Mostrar equipos disponibles
      const teamsMessage = this.linear.formatTeamsForTelegram(teams);
      await ctx.replyWithMarkdown(teamsMessage);

      // Mostrar proyectos disponibles
      const projectsMessage = this.linear.formatProjectsForTelegram(projects);
      await ctx.replyWithMarkdown(projectsMessage);

    } catch (error) {
      console.error('Error in Linear command:', error);
      await ctx.replyWithMarkdown(`
‚ùå **Error conectando con Linear**

${error.message}

Verifica tu LINEAR_API_KEY en las variables de entorno.
      `);
    }
  }

  async handleTasksCommand(ctx) {
    const teamKey = ctx.message.text.replace('/tasks', '').trim();
    
    if (!teamKey) {
      return ctx.replyWithMarkdown(`
‚ùå **Team key requerido**

**Uso:** \`/tasks [team_key]\`

**Ejemplo:** \`/tasks DEV\`

Usa \`/linear\` para ver equipos disponibles.
      `);
    }

    try {
      const processingMsg = await ctx.replyWithMarkdown('üîÑ **Cargando tareas del equipo...**');

      // Buscar equipo por key
      const teams = this.linearCache.get('teams') || await this.linear.getTeams();
      const team = teams.find(t => t.key.toLowerCase() === teamKey.toLowerCase());

      if (!team) {
        await ctx.deleteMessage(processingMsg.message_id);
        return ctx.replyWithMarkdown(`
‚ùå **Equipo no encontrado: ${teamKey}**

Equipos disponibles:
${teams.map(t => `‚Ä¢ \`${t.key}\` - ${t.name}`).join('\n')}
        `);
      }

      // Obtener tareas del equipo
      const teamWithIssues = await this.linear.getIssuesByTeam(team.id);
      
      await ctx.deleteMessage(processingMsg.message_id);

      const issuesMessage = this.linear.formatIssuesForTelegram(
        teamWithIssues.issues.nodes, 
        `${team.name} (${team.key})`
      );
      
      await ctx.replyWithMarkdown(issuesMessage);

    } catch (error) {
      console.error('Error getting team tasks:', error);
      await ctx.replyWithMarkdown(`
‚ùå **Error obteniendo tareas del equipo**

${error.message}
      `);
    }
  }

  async handleProjectTasksCommand(ctx) {
    const projectName = ctx.message.text.replace('/project_tasks', '').trim();
    
    if (!projectName) {
      return ctx.replyWithMarkdown(`
‚ùå **Nombre de proyecto requerido**

**Uso:** \`/project_tasks [project_name]\`

**Ejemplo:** \`/project_tasks "API Development"\`

Usa \`/linear\` para ver proyectos disponibles.
      `);
    }

    try {
      const processingMsg = await ctx.replyWithMarkdown('üîÑ **Cargando tareas del proyecto...**');

      // Buscar proyecto por nombre
      const projects = this.linearCache.get('projects') || await this.linear.getProjects();
      const project = projects.find(p => 
        p.name.toLowerCase().includes(projectName.toLowerCase())
      );

      if (!project) {
        await ctx.deleteMessage(processingMsg.message_id);
        return ctx.replyWithMarkdown(`
‚ùå **Proyecto no encontrado: ${projectName}**

Proyectos disponibles:
${projects.slice(0, 5).map(p => `‚Ä¢ ${p.name}`).join('\n')}
        `);
      }

      // Obtener tareas del proyecto
      const projectWithIssues = await this.linear.getIssuesByProject(project.id);
      
      await ctx.deleteMessage(processingMsg.message_id);

      const issuesMessage = this.linear.formatIssuesForTelegram(
        projectWithIssues.issues.nodes, 
        project.name
      );
      
      await ctx.replyWithMarkdown(issuesMessage);

    } catch (error) {
      console.error('Error getting project tasks:', error);
      await ctx.replyWithMarkdown(`
‚ùå **Error obteniendo tareas del proyecto**

${error.message}
      `);
    }
  }

  async handleAtomizeCommand(ctx) {
    const issueId = ctx.message.text.replace('/atomize', '').trim();
    
    if (!issueId) {
      return ctx.replyWithMarkdown(`
‚ùå **Issue ID requerido**

**Uso:** \`/atomize [issue_id]\`

**Ejemplo:** \`/atomize 123e4567-e89b-12d3-a456-426614174000\`

Usa \`/tasks [team]\` para ver IDs de tareas disponibles.
      `);
    }

    try {
      const processingMsg = await ctx.replyWithMarkdown('üîÑ **Obteniendo tarea de Linear...**');

      // Obtener detalles completos de la tarea
      const issue = await this.linear.getIssueById(issueId);
      
      if (!issue) {
        await ctx.deleteMessage(processingMsg.message_id);
        return ctx.replyWithMarkdown(`
‚ùå **Tarea no encontrada: ${issueId}**

Verifica que el ID sea correcto y tengas acceso a la tarea.
        `);
      }

      await ctx.deleteMessage(processingMsg.message_id);

      // Mostrar detalles de la tarea antes de atomizar
      const taskDetails = `
üéØ **Tarea Linear Seleccionada**

**${issue.identifier}**: ${issue.title}
**Equipo:** ${issue.team.name} (${issue.team.key})
**Estado:** ${issue.state.name}
**Prioridad:** ${this.linear.getPriorityEmoji(issue.priority)}
**Asignado:** ${issue.assignee ? issue.assignee.name : 'Sin asignar'}

**Descripci√≥n:**
${issue.description || 'Sin descripci√≥n'}

**¬øQuieres atomizar esta tarea?**
Responde \`/confirm_atomize ${issueId}\` para continuar.
      `;

      await ctx.replyWithMarkdown(taskDetails);

    } catch (error) {
      console.error('Error getting issue details:', error);
      await ctx.replyWithMarkdown(`
‚ùå **Error obteniendo detalles de la tarea**

${error.message}
      `);
    }
  }

  // GitHub Integration Handlers
  async handleReposCommand(ctx) {
    try {
      if (!process.env.GITHUB_TOKEN) {
        return ctx.replyWithMarkdown(`
‚ùå **GitHub Token no configurado**

Configura GITHUB_TOKEN en tu archivo .env para usar esta funcionalidad.
        `);
      }

      const processingMsg = await ctx.replyWithMarkdown('üîÑ **Cargando repositorios GitHub...**');

      // Obtener repositorios accesibles
      const repositories = await this.github.getRepositories('all', 'updated', 50);

      // Cache para uso posterior
      this.githubCache.set('repositories', repositories);

      await ctx.deleteMessage(processingMsg.message_id);

      // Mostrar repositorios disponibles
      const reposMessage = this.github.formatRepositoriesForTelegram(repositories);
      await ctx.replyWithMarkdown(reposMessage);

    } catch (error) {
      console.error('Error in repos command:', error);
      await ctx.replyWithMarkdown(`
‚ùå **Error obteniendo repositorios**

${error.message}

Verifica tu token de GitHub y permisos.
      `);
    }
  }

  async handleSelectRepoCommand(ctx) {
    const repoPath = ctx.message.text.replace('/select_repo', '').trim();
    
    if (!repoPath || !repoPath.includes('/')) {
      return ctx.replyWithMarkdown(`
‚ùå **Formato de repositorio inv√°lido**

**Uso:** \`/select_repo owner/repository\`
**Ejemplo:** \`/select_repo facebook/react\`

Usa \`/repos\` para ver repositorios disponibles.
      `);
    }

    try {
      const [owner, repo] = repoPath.split('/');
      const processingMsg = await ctx.replyWithMarkdown('üîÑ **Validando acceso al repositorio...**');

      // Validar acceso al repositorio
      const validation = await this.github.validateRepositoryAccess(owner, repo);

      await ctx.deleteMessage(processingMsg.message_id);

      if (!validation.valid) {
        return ctx.replyWithMarkdown(`
‚ùå **Error de acceso al repositorio**

${validation.error}

Verifica que tengas permisos de escritura en este repositorio.
        `);
      }

      // Guardar repositorio seleccionado para el usuario
      const userId = ctx.from.id;
      if (!this.selectedRepositories.has(userId)) {
        this.selectedRepositories.set(userId, []);
      }

      const userRepos = this.selectedRepositories.get(userId);
      const existingRepo = userRepos.find(r => r.full_name === validation.repository.full_name);

      if (existingRepo) {
        return ctx.replyWithMarkdown(`
‚úÖ **Repositorio ya seleccionado**

**${validation.repository.full_name}** ya est√° en tu lista de repositorios.

Usa \`/my_repos\` para ver todos tus repositorios seleccionados.
        `);
      }

      userRepos.push({
        ...validation.repository,
        selectedAt: new Date().toISOString()
      });

      const successMessage = `
‚úÖ **Repositorio seleccionado exitosamente**

**üìÅ ${validation.repository.full_name}**
${validation.repository.description ? `üìù ${validation.repository.description}` : ''}

**Permisos:** ${validation.repository.permissions.admin ? 'üëë Admin' : '‚úçÔ∏è Write'}
**Branch principal:** \`${validation.repository.default_branch}\`

**Siguiente paso:**
- \`/repo_structure ${validation.repository.full_name}\` - Ver estructura
- \`/my_repos\` - Ver todos tus repositorios
      `;

      await ctx.replyWithMarkdown(successMessage);

    } catch (error) {
      console.error('Error selecting repository:', error);
      await ctx.replyWithMarkdown(`
‚ùå **Error seleccionando repositorio**

${error.message}
      `);
    }
  }

  async handleRepoStructureCommand(ctx) {
    const repoPath = ctx.message.text.replace('/repo_structure', '').trim();
    
    if (!repoPath || !repoPath.includes('/')) {
      return ctx.replyWithMarkdown(`
‚ùå **Formato de repositorio inv√°lido**

**Uso:** \`/repo_structure owner/repository\`
**Ejemplo:** \`/repo_structure facebook/react\`
      `);
    }

    try {
      const [owner, repo] = repoPath.split('/');
      const processingMsg = await ctx.replyWithMarkdown('üîÑ **Obteniendo estructura del repositorio...**');

      // Obtener estructura del repositorio
      const structure = await this.github.getRepositoryStructure(owner, repo, '', 3);

      await ctx.deleteMessage(processingMsg.message_id);

      // Formatear y mostrar estructura
      const structureMessage = this.github.formatRepositoryStructureForTelegram(structure, repoPath);
      await ctx.replyWithMarkdown(structureMessage);

    } catch (error) {
      console.error('Error getting repository structure:', error);
      await ctx.replyWithMarkdown(`
‚ùå **Error obteniendo estructura**

${error.message}

Verifica que tengas acceso a este repositorio.
      `);
    }
  }

  async handleMyReposCommand(ctx) {
    const userId = ctx.from.id;
    const userRepos = this.selectedRepositories.get(userId) || [];

    if (userRepos.length === 0) {
      return ctx.replyWithMarkdown(`
üìÇ **No tienes repositorios seleccionados**

Usa \`/repos\` para ver repositorios disponibles y \`/select_repo [owner/repo]\` para seleccionar.
      `);
    }

    let message = 'üìÅ **Tus repositorios seleccionados:**\n\n';

    userRepos.forEach((repo, index) => {
      const selectedDate = new Date(repo.selectedAt).toLocaleDateString();
      const visibility = repo.private ? 'üîí Privado' : 'üåê P√∫blico';
      
      message += `${index + 1}. **${repo.name}**\n`;
      message += `   ${visibility} ‚Ä¢ \`${repo.full_name}\`\n`;
      message += `   üìÖ Seleccionado: ${selectedDate}\n`;
      message += `   üîó \`/repo_structure ${repo.full_name}\`\n\n`;
    });

    message += '*Estos repositorios ser√°n considerados para la atomizaci√≥n de tareas.*';

    await ctx.replyWithMarkdown(message);
  }

  async start() {
    try {
      // Inicializar base de datos
      await this.db.initialize();
      
      // Iniciar bot
      await this.bot.launch();
      console.log('ü§ñ Telegram Task Agent iniciado correctamente');
      console.log('üîë Bot token configurado:', !!process.env.TELEGRAM_BOT_TOKEN);
      console.log('üìù Comandos disponibles: /start, /project, /list, /status, /help');
      
      // Graceful shutdown
      process.once('SIGINT', () => this.bot.stop('SIGINT'));
      process.once('SIGTERM', () => this.bot.stop('SIGTERM'));
      
    } catch (error) {
      console.error('‚ùå Error iniciando bot:', error);
      process.exit(1);
    }
  }
}

// Iniciar bot si se ejecuta directamente
if (require.main === module) {
  const bot = new TelegramTaskBot();
  bot.start();
}

module.exports = TelegramTaskBot;